include("/Classes/Leek")
include("/Classes/Items/Weapon")
include("/Classes/Context/World")
include("/Classes/Context/DangerMap")
include("/Classes/Plannification/Action")
include("/Toolbox/Constants")
include("/Classes/Context/Combo")

/**
 * Classe Plannification qui g�re la planification des actions d'un poireau dans le jeu.
 */
class Plannification {
	public Leek | null leek = null
	public Array < Action > actions = []
	public integer tpLeft = 0
	public integer mpLeft = 0
	public Coordinates cellToShootFrom = new Coordinates()
	public Weapon | null chosenWeapon = null
	public boolean willShoot = false

	/**
	 * Constructeur de la classe Plannification.
	 *
	 * @param l - Le poireau pour lequel la planification est effectu�e.
	 */
	constructor(Leek l) {
		leek = l
		tpLeft = leek.tp
		mpLeft = leek.mp
		actions = []
		cellToShootFrom = new Coordinates()
		willShoot = false
	}

	/**
	 * Choisis une arme pour le poireau.
	 */
	void chooseWeapon() {
		if (chosenWeapon == null)
			chosenWeapon = leek.wearedWeapons[0]
	}

	void planChipsActions() {
		Array<Chip> leekChips = leek.cooledChips
		while(tpLeft && count(leekChips)>0){
			Action? bestAction = null;
			real largestDammages = 1 
			Chip? usedChip = null
			Set<integer> fromSet = new Set()
			setPut(fromSet, cellToShootFrom.cell)
			for(Chip wc in  leekChips)
			{	
				debug("wc name " + wc.name)
				Set < integer > cellsToUseFrom = wc.fromWhereToUse(leek.target, leek.reachableCells)
				if(wc.cost > tpLeft || cellsToUseFrom == <>)
				   {
				   		removeElement( leekChips, wc)
						debug("remove wc " + wc.name + " " + wc.cost + " cell " + cellsToUseFrom + ".")
						mark(setToArray(cellsToUseFrom),COLOR_BLUE)
						pause()
						clearMarks()
						
				   }
				else
				{
					debug("wc meanDammage " + wc.meanDammage)
					if(
						wc.meanDammage > largestDammages 
					)
					{
						largestDammages = wc.meanDammage
						bestAction = new Action("use chip " + wc.name  , 
												function() {
													wc.useOnTarget(leek.target)
												}, 
												" on " + leek.target.name)
						usedChip = wc
						debug("new action " + wc.name + " action " + bestAction)
					}
				}
			}
			if (bestAction != null )
			{
				push(actions,bestAction)
				removeElement( leekChips, usedChip)
			}

		}
		


	}


	/**
	 * Planifie l'�quipement d'une arme par le poireau.
	 */
	void planEquipWeapon() {
		chooseWeapon() //faire un choix �clair�$
		if (leek.equipedWeapon.id != chosenWeapon.id) {
			push(actions, new Action("equip weapon " , function() {
				leek.equipWeapon(chosenWeapon)
			}, 
		    chosenWeapon.name))
			tpLeft = tpLeft - 1

		}
	}

	/**
	 * Planifie le d�placement du poireau.
	 */
	void planMove() {
		Set < integer > cellsToShootFrom = leek.wearedWeapons[0].fromWhereToUse(leek.target, leek.reachableCells)
		integer distance = 20
		if (cellsToShootFrom == < > ) {
			// move towards target full speed
			while (mpLeft > 0) {
				push(actions, new Action("move toward ", function() {
					leek.moveTowardTarget()
				}, "Move towards enemy"))
				mpLeft = mpLeft - 1
				// insérer possibilité d'utiliser une puce pour tirer sur l'ennemi si distance and Los
			}
		} else {
			if (cellsToShootFrom != < > ) {
				Map < integer, integer > cellsDistanceToLeek = new Map()
				for (integer c in cellsToShootFrom) {

					mapPut(cellsDistanceToLeek, c, getPathLength(leek.cell, c))
				}
				distance = mapMin(cellsDistanceToLeek)
				cellToShootFrom = world.getCoordinatesFromCell(mapSearch(cellsDistanceToLeek, distance))
				willShoot = (getPathLength(cellToShootFrom.cell, leek.cell) <= leek.mp)
				mark(cellToShootFrom.cell, COLORS.WARNING)
			} else {
				cellToShootFrom = world.getCoordinatesFromCell(leek.target.cell)
				distance = getPathLength(leek.cell, cellToShootFrom.cell)
				mark(cellToShootFrom.cell, COLORS.BROWN)
				debugC("pourquoi a t on ce cas ?", COLOR_RED)
				pause() // pourquoi a t on ce cas ? 
			}
			pause()

			push(actions, new Action("moveTowardOneCell " + cellToShootFrom, function() {
				leek.moveTowardOneCell(cellToShootFrom.cell)
			}, "cell to shoot from " + cellsToShootFrom ))

			mpLeft = mpLeft - distance
		}
	}

	/**
	 * Planifie le tir du poireau.
	 */
	void planShoot() {
		if (willShoot)
			while (tpLeft >= chosenWeapon.cost) {
				debug("planshoot + tpleft " + tpLeft)
				push(actions, new Action("shoot", function() {
					leek.shoot()
				}, 
				"planshoot + tpleft after" + tpLeft))
				tpLeft = tpLeft - chosenWeapon.cost
			}
		debug("planshoot + tpleft after" + tpLeft)
	}

	/**
	 * Planifie la dissimulation du poireau.
	 */
	void planHide() {
		if (mpLeft > 0) {
			Coordinates safeCell = leek.dangerMap.getPlaceToHide(leek, leek.target, cellToShootFrom, mpLeft)
			debugC("place to hide " + safeCell, COLOR_RED)
			pause()
			if (safeCell.cell > -1) {
				Map < integer, integer > distanceToSafeCells = new Map()
				push(actions, new Action("hide", function() {
					leek.moveTowardOneCell(safeCell.cell)
				},"safe place : " + safeCell
				))

			}

		}

	}





	/**
	 * Ex�cute les actions planifi�es.
	 */
	void execute() {
		debug("Actions" + actions)
		while (count(actions) > 0) {
			Action toExecute = shift(actions)
			debug("play " + toExecute.name)
			toExecute.action()

		}

	}

}