include("/Toolbox/Constants")
include("/Classes/Leek")
include("/Classes/Context/World")
include("/Classes/Context/DangerInfo")
include("/Classes/Context/Coordinates")



/**
 * Represents a map of danger in the game.
 */
class DangerMap2 {
    /**
     * The map containing coordinates as keys and danger info as values.
     */
    Map<Coordinates, DangerInfo> map = new Map() // coordinates as key, dangerInfo as value

    /**
    * Initializes the DangerMap by resetting it and populating it with default DangerInfo objects.
    * @returns {DangerMap} - The initialized DangerMap.
    */
    DangerMap initialize() {
        // Reset the DangerMap.
        resetMap()

        // Iterate over each cell in the game world and populate the DangerMap with default DangerInfo objects.
        for (Coordinates cell in world.cellsCoordinatesTable) {


            // Create a new default DangerInfo object.
            DangerInfo dangerInfo = new DangerInfo(cell.cell)

            // Associate the Coordinates object with the DangerInfo object in the DangerMap.
            mapPut(map, cell, dangerInfo)
        }
    }



    /**
     * Resets the danger map.
     */
    void resetMap() {
        map = new Map()
    }

    /**
    * Finds the danger with the minimum weight in the DangerMap.
    * @returns {DangerInfo} - The danger with the minimum weight.
    */
    DangerInfo getDangerWithMinWeight() {
        // Initialize a DangerInfo object with default values.
        DangerInfo min = new DangerInfo()

        // Iterate over each DangerInfo object in the map.
        for (DangerInfo el in map) {
            // Check if the weight of the current DangerInfo object is less than or equal to the minimum weight found so far.
            // If true, update the minimum DangerInfo object.
            if (min.weight >= el.weight)
                min = el 
        }

        // Return the DangerInfo object with the minimum weight.
        return min
    }

    /**
    * Gets the cell associated with the provided DangerInfo from the DangerMap.
    * @param {DangerInfo} d - The DangerInfo object.
    * @returns {Coordinates} - The cell associated with the DangerInfo.
    */
    Coordinates getCellFromDangerInfo(DangerInfo d) {
        // Search the DangerMap for the cell associated with the provided DangerInfo.
        return mapSearch(map, d)
    }

    /**
    * Gets cells from the DangerMap based on a weight comparison.
    * @param {integer} weight - The weight to compare against.
    * @param {integer} comparison - The type of comparison to perform.
    * @returns {Set<Coordinates>} - The set of cells satisfying the comparison.
    */
    Set<Coordinates> getCellsFromWeight(integer weight, integer comparison) {
        // Initialize the set to store cells satisfying the comparison.
        Set<Coordinates> ret = new Set()

        // Perform different comparisons based on the provided comparison type.
        if (comparison == CONST_EQUAL) {
            // Iterate over each DangerInfo in the DangerMap and add cells with matching weights to the set.
            for (DangerInfo d in map)
                if (d.weight == weight)
                    setPut(ret, d)
        }
        else if (comparison == CONST_MIN_OR_EQUAL) {
            // Iterate over each DangerInfo in the DangerMap and add cells with weights less than or equal to the provided weight to the set.
            for (DangerInfo d in map)
                if (d.weight <= weight)
                    setPut(ret, d)
        }
        else if (comparison == CONST_MIN) {
            // Iterate over each DangerInfo in the DangerMap and add cells with weights less than the provided weight to the set.
            for (DangerInfo d in map)
                if (d.weight < weight)
                    setPut(ret, d)
        }
        else if (comparison == CONST_SUP_OR_EQUAL) {
            // Iterate over each DangerInfo in the DangerMap and add cells with weights greater than or equal to the provided weight to the set.
            for (DangerInfo d in map)
                if (d.weight >= weight)
                    setPut(ret, d)
        }
        else if (comparison == CONST_SUP) {
            // Iterate over each DangerInfo in the DangerMap and add cells with weights greater than the provided weight to the set.
            for (DangerInfo d in map)
                if (d.weight > weight)
                    setPut(ret, d)
        }

        // Return the set of cells satisfying the comparison.
        return ret
    }



    /**
     * Finds the furthest less dangerous cell from a given cell among reachable cells.
     * @param {Coordinates} fromCell - The starting cell.
     * @param {Set<Coordinates>} reachableCells - The set of reachable cells.
     * @returns {Coordinates} - The furthest less dangerous cell.
     */
   /* integer getFurthestLessDangerous(Coordinates fromCell, Set<Coordinates> reachableCells) {
        // Initialize variables.
        integer result = -1
        Map<Coordinates, DangerInfo> reachableCellsEvenDangerousOne = mapFilter(this.map, (DangerInfo value, Coordinates key) => boolean {
            // Filter reachable cells based on whether they are in the reachableCells set.
            debug("key " + key )
            return (setContains(reachableCells, key))
        })

        // Get the minimum danger value among reachable cells.
        DangerInfo min = reachableCellsEvenDangerousOne.getDangerWithMinWeight()

        // Filter reachable cells based on minimum danger value.
        Map<integer, real> lessDangerousCells = mapFilter(reachableCellsEvenDangerousOne, (real value, integer key) => boolean {
            return (min == value)
        })

        // Debug and mark less dangerous cells.
        debug("lessDangerousCells" + lessDangerousCells)
        mark(mapKeys(lessDangerousCells), COLOR_SALMON)
        debugPause()

        // Find the furthest cell among less dangerous cells.
        integer ret = getFurthestCellFromSet(fromCell, arrayToSet(mapKeys(lessDangerousCells)))
        debug("getFurthestLessDangerous " + ret)
        mark(ret, COLOR_BROWN)
        pause()

        // Return the furthest less dangerous cell.
        return ret
    }*/

    /**
     * Finds a place to hide for a leek from an enemy.
     * @param {Leek} me - The current leek.
     * @param {Leek} enemy - The enemy leek.
     * @param {integer} origin - The original cell of the leek.
     * @param {integer} mp - The movement points of the leek.
     * @returns {integer} - The cell to hide.
     */
    integer getPlaceToHide(Leek me, Leek enemy, integer origin, integer mp) {
        // Initialize variables.
        integer placeToHide = -1
        Set<integer> reachableCellsToHide = me.getReachableCellsFromCell(origin, mp)
        Set<integer> safePlaces = <>

        // Debug information.
        debug("place to hide ")
        debug("leek cell " + me.name + " " +  me.cell)
        debug("orignie du calcul : place ou on est " + origin + " mp " + mp)
        debug("enemy cell " + enemy.name + " " +  enemy.cell)
        debug("reachableCellsToHide " + reachableCellsToHide)
        debugPause()

        // Check if reachable cells to hide are empty.
        if (reachableCellsToHide == <>) {
            debug("No cells reachable to hide")
        } else {
            // Find safe places by subtracting dangerous places from reachable cells.
            Set<integer> dangerousPlaces = arrayToSet(mapKeys(me.dangerMap.map))
            debug("DangerousPlaces places")
            mark(setToArray(dangerousPlaces), COLOR_HIT)
            safePlaces = setDifference(reachableCellsToHide, dangerousPlaces)
            debugPause()
            debug("safe places " + safePlaces)
            mark(setToArray(safePlaces), COLOR_LIGHT_GREEN)
            debugPause()

            // Find the furthest safe cell from the enemy.
            debug("enemy.cell " + enemy.cell)
            integer safe = getFurthestCellFromSet(enemy.cell, safePlaces)
            if (safe > -1)
                placeToHide = safe
            else {
                // If no safe cell found, find the furthest less dangerous cell.
     //           placeToHide = getFurthestLessDangerous(enemy.cell, reachableCellsToHide)
            }

            debug("placeToHide " + placeToHide)
            mark(placeToHide, COLOR_YELLOW)
            debugPause()
        }
        // Return the cell to hide.
        return placeToHide
    }

    /**
     * Builds the danger map based on the weapons of an enemy.
     * @param {Leek} enemy - The enemy leek.
     * @returns {Map} - The danger map.
     */
    Map buildDangerMap(Leek enemy) {
        // Initialize variable.
        integer damage = -1

        // Iterate over each weapon of the enemy.
        for (Weapon w in enemy.wearedWeapons) {
            damage = 0
            // Find cells to shoot to for the weapon.
            Set<integer> cellsToShootTo = w.whereCanHeShoot(enemy.reachableCells)

            // Update danger map with damage caused by the weapon.
            for (integer c in cellsToShootTo) {
                mapPut(map, c, mapGet(map, c, 0) + w.meanDammage)
            }
        }

        // Return the built danger map.
        return map
    }
}
