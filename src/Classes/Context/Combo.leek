include("/Classes/Context/World")
include ("/Classes/Leek")
include ("/Classes/Plannification/Action")
include ("/Toolbox/Helpers")

class ComboResult{
	public Array < Action > actions = []
	public real minDamage = 0.0
	public real maxDamage = 0.0
	public real meanDamage = 0.0
	public integer tpLeft = 0 
	public integer mpLeft = 0 
	public Weapon lastUsedWeapon 
	
	constructor(ComboResult original){
		minDamage = original.minDamage
		maxDamage = original.maxDamage
		meanDamage = original.meanDamage
		tpLeft = original.tpLeft
		mpLeft = original.mpLeft
		lastUsedWeapon = original.lastUsedWeapon
		for(Action a in original.actions )
			push(actions, a)
	}
}

class Combo{
	public Array<ComboResult> results = []
	public Leek? shooter = null
	public Leek? target = null
	public Array<integer>  path = []
	public integer pathLength 
	
	
	constructor (Leek sh ,Leek tar){
		shooter =sh
		target = tar
		path = getPath(shooter.coordinates.cell, target.coordinates.cell)
		pathLength = count(path)
		
	}

	void generateCombos(){
		ComboResult result = new ComboResult()
		result.lastUsedWeapon = shooter.equipedWeapon
		generateCombosResults(result,0)
	}

	

	void generateCombosResults(ComboResult cr, integer stepsDone){
		ComboResult current = new ComboResult(cr)
		
		for(integer i = stepsDone ; i <= current.mpLeft and i < pathLength  ; ++i) { 
			Array<Item> usableItems = shooter.getUsableDamagingItems(getCellDistance(path[i], target.coordinates.cell), 
																	 lineOfSight(path[i], target.coordinates.cell),
																	 current.tpLeft
																	)
			
			
			if(i > 0 ){
				push(current.actions, new Action("move toward cell", function() {
					moveTowardCell(path[i],1)
				}, "Move towards cell " + path[i] + " for 1 step"))
				current.mpLeft = current.mpLeft -1
				stepsDone = stepsDone +1
			}
			
			for(Item item in usableItems){
				
			}

			if (count(usableItems)>0){
				for(Item item in usableItems){
					if ((item.cost <= current.tpLeft and current.lastUsedWeapon == item) or
						(current.lastUsedWeapon != item and (item.cost+1) <= current.tpLeft)){
						ComboResult next = new ComboResult(current)
						if(item.type == "Weapon" and next.lastUsedWeapon != item)
						{
							push(next.actions, item.getActionEquip(shooter))	
							next.tpLeft = next.tpLeft -1 
						}
						push(next.actions, item.getActionUse(shooter, target))
						next.tpLeft = next.tpLeft -item.cost 
					}
					else
						removeElement(usableItems, item)
					
				}
			}
		}
		
		
	}
}